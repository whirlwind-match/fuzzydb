/******************************************************************************
 * Copyright (c) 2005-2008 Whirlwind Match Limited. All rights reserved.
 *
 * This is open source software; you can use, redistribute and/or modify
 * it under the terms of the Open Software Licence v 3.0 as published by the 
 * Open Source Initiative.
 *
 * You should have received a copy of the Open Software Licence along with this
 * application. if not, contact the Open Source Initiative (www.opensource.org)
 *****************************************************************************/
package org.fuzzydb.attrs.byteencoding;


import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.Iterator;
import java.util.NoSuchElementException;

import org.fuzzydb.core.whirlwind.internal.IAttribute;
import org.fuzzydb.core.whirlwind.internal.IAttributeConstraint;
import org.fuzzydb.core.whirlwind.internal.IAttributeMap;

import com.wwm.util.ByteArray;

/**
 * Compact implementation of IAttributeMap that encodes and decodes attributes to and from a ByteArray
 *
 * @author Neale
 *
 */
public class CompactAttrMap<T extends IAttribute> implements Cloneable, IAttributeMap<T>, Serializable {

	private static final long serialVersionUID = 1L;

	/**
	 * Single byte array.  we might consider seperating booleans, and others so we know where to look for a given attrId.
	 * Prob not worth it, as here we L1 cache benefit.
	 */
	private ByteArray bytes = new ByteArray(6); // This'll get trimmed, if over allocated for item attr containers, but for nodes, we want it small for the early node attr containers splitting on enums and bools


	/**
	 * Iterate over compact attributes, and then over fat ones.
	 */
	public class MapIterator implements Iterator<T> {

		int index = 0;

		public boolean hasNext() {
			return index < bytes.size();
		}

		@SuppressWarnings("unchecked")
        public T next() {
			if (index >= bytes.size()){
				// If we've run out of compact attrs, throw NoSuchElementException
				throw new NoSuchElementException();
			}

			// decode next compact one
			int headerWord = CompactAttrCodec.getHeaderWord(bytes, index);
			int length = CompactAttrCodec.getLength(bytes, index, headerWord) + 0;
			CompactAttrCodec codec = CodecManager.getCodec( bytes, index );
			T attr = (T) codec.getDecoded( bytes, index );
			index += length;
			return attr;
		}

		public void remove() {
			throw new UnsupportedOperationException();
		}
	}






	/**
	 * Add attribute.  The attrId is used to establish the type, so must
	 * have been generated by AttrDefinitionMgr
	 * @param attrId
	 * @param value
	 */
	@SuppressWarnings("unchecked")
    public void addAttribute(int attrId, Object value) {
		CompactAttrCodec codec;
		if (value instanceof IAttributeConstraint){
			 codec = CodecManager.getConstraintCodec( attrId );
		} else {
			codec = CodecManager.getCodec( attrId );
		}
		if (codec != null) {
			codec.encodeToByteArray(bytes, attrId, value);
		} else {
			throw new RuntimeException("Couldn't find codec for " + value);
		}
	}


	/**
	 * See if the requested attribute is present, and if it is, return the 'merged' IAttribute
	 * representation from the AttributeCache
	 */
	@SuppressWarnings("unchecked")
    public T findAttr(int attrId) {
		// Find attr from within our ByteArray
		int index = CompactAttrCodec.findAttrInBuf( bytes, attrId );

		// If not found, return null
		if (index < 0) {
			return null;
		}

        CompactAttrCodec codec = CodecManager.getCodec( bytes, index );
		T attr = (T) codec.getDecoded( bytes, index );

		return attr;
	}


	public T put(int attrId, T value) {

		Object db2Value = value.asSimpleAttribute();
		addAttribute(attrId, db2Value );
		return null; // TODO: Could return prev value if there was one
	}


	public T putAttr(T attr) {
		return put( attr.getAttrId(), attr);
	}

	public T removeAttr(int attrId) {
		throw new UnsupportedOperationException();
	}

	public int size() {
		return bytes.size();
	}

	public Iterator<T> iterator() {
		return new MapIterator();
	}

	// Overload write object so that we don't put CompactAttrMap in the serialisation stream, just the bytes
	// themselves.
	private void writeObject(ObjectOutputStream out) throws IOException {
		bytes.customWriteObject( out );
	}

	// Read back just the bytes with no class overhead
	@SuppressWarnings("unchecked")
    private void readObject(ObjectInputStream in) throws IOException {
		bytes = new ByteArray(1);
		bytes.customReadObject(in);

		// FIXME: Validating
		for ( @SuppressWarnings("unused") IAttribute ia : this) {
			// just iterating over the whole lot to test we've got a valid set
		}
	}

	@SuppressWarnings("unchecked")
	@Override
	public boolean equals(Object obj) {
		CompactAttrMap<T> rhs = (CompactAttrMap<T>) obj;
		return bytes.equals(rhs.bytes);
	}

	@Override
	public int hashCode() {
		return bytes.hashCode();
	}
	
	public ByteArray getByteArray() {
		return bytes;
	}

	@SuppressWarnings("unchecked")
    @Override
	public CompactAttrMap clone(){
// FIXME: implement this properly .. currently not used (at least, not as far as start
		try {
			CompactAttrMap clone = (CompactAttrMap) super.clone();
			clone.bytes = this.bytes.clone();
			return clone;
//			// FIXME: Aren't we supposed to clone the rest
//			// FIXME: NOTE: Where we're clone()ing arrays, use arraycopy instead (as it's much slower, pre java 7)
		} catch (CloneNotSupportedException e) {
			throw new RuntimeException(e); // Should always impl
		}
	}


	@Override
	public String toString() {
		StringBuilder str = new StringBuilder();
		for ( IAttribute ia : this) {
			str.append("  ").append( ia.toString() ).append( System.getProperty( "line.separator") );
		}
		return str.toString();
	}
	
    /**
     * Does what used to be done in Branch.qualify
     */
	public boolean consistentFor(IAttributeConstraint constraint, int splitId) {
		IAttribute att = findAttr(splitId);
		if (att == null) {
			if (constraint == null)
			 {
				return true;	// no attribute + no constraint, this is the right branch
			}
			return false; // no attribute but there is a constraint, wrong branch - need the one with no contraint
		}
		if (constraint == null)
		 {
			return false;	// there is an attribute matching split id, must select a constrained branch
		}
				
		return constraint.consistent(att);
	}

}
